============
Sifteo TC VM
============

What is it?
-----------

 - Like Native Client, but for small-memory microcontrollers
 - A paravirtualization environment
 - A language VM that happens to be partially Thumb-compatible
 - A safe Direct Execution environment for untrusted code
 - A hardware-assisted sandboxing interpreter

Memory Protection
-----------------

We use SP (r13) as a trusted base register. It can only be updated by trusted
code. It may only point to RAM within the sandbox. Safe instructions are
allowed to apply a small positive offset to SP.

To catch NULL pointers, other bad pointers, or out-of-range indexing (SP in
range, SP + offset out of range) we use a simple technique that requires only
trivial hardware assistance.

When a pointer is loaded into SP, it is sanitized using the following algorithm:

  SP = ((pointer - 0x10000) & 0xFFFFF) + 0x20008000;

This assumes the VM's memory layout is as follows:

  00000000 - 0000FFFF     Invalid (guard region to catch NULL pointers)
  00010000 - 00017FFF     32 kB of user RAM for stack and data
  00018000 - 7FFFFFFF     Invalid
  80000000 - FFFFFFFF     External data (Flash) virtual address space

And the physical machine's layout is:

  00000000 - 1FFFFFFF     System code space
  20000000 - 20007FFF     32 kB system data space
  20008000 - 2000FFFF     32 kB user data space
  20010000 - 21FFFFFF     Unimplemented in hardware, causes trap

Example virtual to physical translations:

  00000000 -> 200F8000    Invalid, causes trap
  0000FFFF -> 20107FFF    Invalid, causes trap
  00010000 -> 20008000    First byte in user RAM
  00017FFF -> 2000FFFF    Last byte in user RAM
  00018000 -> 20010000    Invalid, causes trap
  0001FFFF -> 20017FFF    Invalid, causes trap
  000FFFFF -> 200F7FFF    Invalid, causes trap
  00110000 -> 20008000    Invalid, causes aliasing
  FFFFFFFF -> 200F7FFF    Invalid, causes trap

This approach allows the most common pointer errors to be caught at load/store
time. Uncaught pointer errors can reference the wrong address, but they can't
escape the sandbox. By placing the user RAM at the end of mapped SRAM, the
hardware's unimplemented memory region creates a natural guard which catches
errors in which a valid SP has been added to a too-large offset. (These errors
cannot be caught statically)

Instruction Set Architecture
----------------------------

IT blocks and 32-bit Thumb-2 instruction words are forbidden for now. Perhaps
they will be allowed later, but right now it's a nice simplifying assumption
to make all instructions 16-bit and to assume all instruction boundaries are
valid jump targets:

  10111111 xxxxxxxx     # IT block

  11101xxx xxxxxxxx     # Prefixes
  11110xxx xxxxxxxx
  11111xxx xxxxxxxx

Thumb encoding that are always allowed:

  '00xxxxxx xxxxxxxx',  # Shift, add, subtract, mov, cmp
  '010000xx xxxxxxxx',  # Data processing (r0-r7)
  '1001xxxx xxxxxxxx',  # Load/store [SP, #imm8]
  '10110010 xxxxxxxx',  # Sign/zero extend
  '10111010 0xxxxxxx',  # REV / REV16
  '10111010 11xxxxxx',  # REVSH

Encodings we may allow as hypercalls / pseudo-ops:

  '10111110 xxxxxxxx',  # Breakpoint
  '11011110 xxxxxxxx',  # Undefined instruction
  '11011111 xxxxxxxx',  # Supervisor call

Encodings that are allowed pending static bounds checks:

  '01001xxx xxxxxxxx',  # Load literal
  '1011x0x1 xxxxxxxx',  # CBZ / CBNZ
  '1101xxxx xxxxxxxx',  # Conditional branch
  '11100xxx xxxxxxxx',  # Unconditional branch

Assisted operations
-------------------

Many common operations require hypercall assistance:

 - Word or byte-wide loads/stores
 - Loading SP with an arbitrary pointer
 - Loading SP with the current stack frame
 - Procedure call and return
 - Long branches

Since we have a relatively large space (at least 512 codes) for hypercall use,
we may choose to use some of these codes for direct (function-like)
hypercalls, and some of them for indirect operations in which the parameter,
Rather than being a hypercall ID, is actually an offset to arguments in the
literal pool.

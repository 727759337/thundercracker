#!/usr/bin/env python
#
# Simple tileset/tilemap generator.
# M. Elizabeth Scott <beth@sifteo.com>
# 
# Copyright (c) 2011 Sifteo, Inc.
#

import Image
import os.path
from optparse import OptionParser
import struct


class Tiler:
    def __init__(self, baseAddr=0, tileSize=8, format="RGB"):
        self.tileHash = {}
        self.tileList = []
        self.baseAddr = baseAddr
        self.tileSize = tileSize
        self.format = format
        self.totalTileCount = 0

    def addOrReferenceTile(self, data):
        self.totalTileCount += 1
        if data not in self.tileHash:
            self.tileHash[data] = len(self.tileList)
            self.tileList.append(data)
        return self.tileHash[data]

    def makeTileImage(self):
        numTiles = len(self.tileList)
        print ("Creating tileset image with %d tiles (%d total, %.02f%% compression)"
               % (numTiles, self.totalTileCount,
                  (1.0 - (numTiles / float(self.totalTileCount))) * 100))

        im = Image.new(self.format, (self.tileSize, self.tileSize * numTiles))
        for i, data in enumerate(self.tileList):
            tile = Image.fromstring(self.format, (self.tileSize, self.tileSize), data)
            im.paste(tile, (0, i*self.tileSize, self.tileSize, (i+1)*self.tileSize))
        return im

    def encodeTileAddress(self, index):
        linear = self.baseAddr + (index << 7)
        low = ((linear >> 7) & 0x7F)
        high = ((linear >> 14) & 0x7F)
        return (high << 9) | (low << 1)

    def processMap(self, image, name, headerFile, indexFile):
        image = image.convert(self.format)
        width, height = image.size

        if (width % self.tileSize) or (height % self.tileSize):
            raise ValueError("Map %r of size %dx%d pixels is not a multiple of our %d pixel tile-size"
                             % (name, width, height, self.tileSize))
        width /= self.tileSize
        height /= self.tileSize
        count = 0
        
        print "Processing map %r, %dx%d tiles" % (name, width, height)

        headerFile.write("// Generated by tiler.py\n")
        headerFile.write("// baseAddr = 0x%08x\n" % self.baseAddr)
        headerFile.write("// name = %s\n" % name)
        headerFile.write("\n")
        headerFile.write("#define MAP_WIDTH_%s %d\n" % (name, width))
        headerFile.write("#define MAP_HEIGHT_%s %d\n" % (name, height))
        headerFile.write("{\n")

        for y in range(height):
            for x in range(width):
                tile = image.crop((x * self.tileSize, y * self.tileSize,
                                   (x+1) * self.tileSize, (y+1) * self.tileSize))
                index = self.addOrReferenceTile(tile.tostring())
                address = self.encodeTileAddress(index)
                count += 1

                headerFile.write("0x%04x, " % address)
                indexFile.write(struct.pack("<H", index))

                if (count & 7) == 0:
                    headerFile.write("\n")

        headerFile.write("};\n\n")


if __name__ == "__main__":
    parser = OptionParser(usage = "usage: %prog [options] maps")
    parser.add_option("-t", "--tiles", dest="tiles",
                      help="write tiles as an image to FILE",
                      metavar="FILE.png", default="tiles.png")
    parser.add_option("-s", "--size", dest="size",
                      help="Set the tile size, in pixels",
                      metavar="PIXELS", default=8, type="int")
    parser.add_option("-b", "--base", dest="base",
                      help="Set the tile base address",
                      metavar="BYTES", default=0, type="int")

    (options, args) = parser.parse_args()

    # Open all input files first
    maps = [(Image.open(m),
             os.path.splitext(os.path.basename(m))[0])
            for m in args]

    t = Tiler(options.base, options.size)

    for mapImage, mapName in maps:
        headerFile = open("%s.h" % mapName, "w")
        indexFile = open("%s.map" % mapName, "wb")
        t.processMap(mapImage, mapName, headerFile, indexFile)

    t.makeTileImage().save(options.tiles)

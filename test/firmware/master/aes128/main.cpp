
#include "aes128.h"
#include "macros.h"

#include "string.h"

static const uint8_t testdata[1015] = {
    0x00,0x40,0x4f,0x40,0x20,0x0f,0x00,0x14,0x4b,0x55,0x53,0x16,0x6c,0xd2,0x4a,0x80,
    0xa7,0x17,0x9c,0x5e,0x71,0x7a,0xc5,0xe9,0x17,0xa7,0x5e,0x9c,0x7a,0x71,0xe9,0xc5,
    0x20,0x03,0x00,0x00,0x00,0x40,0x4f,0x61,0xff,0xe8,0xef,0xef,0xef,0xff,0x0d,0x02,
    0xaa,0x58,0x80,0x54,0x15,0x52,0x15,0x52,0x15,0x52,0x15,0x52,0x15,0x54,0x95,0x03,
    0x31,0xa1,0x85,0xbf,0x54,0xbf,0x54,0x2f,0x55,0xa0,0x54,0x05,0x50,0xd5,0xbf,0x54,
    0xbf,0x54,0x2f,0x55,0xa0,0x54,0x05,0x50,0x55,0x54,0x15,0x52,0x15,0x4b,0x55,0xb0,
    0x54,0x05,0x4b,0x55,0xb0,0x54,0x05,0x52,0x15,0x54,0x95,0xff,0xb0,0xf4,0x0f,0x52,
    0xaa,0x40,0x05,0x00,0x55,0x20,0x55,0x41,0x55,0xf9,0x52,0x05,0x2f,0x55,0xf0,0x52,
    0x05,0x2f,0x55,0xb0,0x54,0x05,0x52,0x15,0x54,0x55,0xff,0xb0,0xf4,0x0f,0x52,0xaa,
    0x40,0x05,0x00,0x55,0x5f,0x04,0x34,0xb3,0xa1,0x11,0x1f,0x51,0x00,0x10,0x41,0x44,
    0x00,0x11,0x33,0x03,0x02,0x11,0x32,0x13,0x02,0x11,0x31,0x13,0x02,0x11,0x1f,0xf1,
    0x11,0x07,0x11,0x45,0x10,0x41,0x23,0x10,0x31,0x05,0x00,0x4f,0xae,0x55,0x01,0x34,
    0x13,0x55,0x01,0x34,0x13,0x55,0x02,0x32,0x03,0x55,0x03,0x22,0x50,0x45,0x00,0x10,
    0xf1,0x11,0x35,0x13,0x02,0x11,0x31,0x13,0x02,0x11,0x31,0x03,0x02,0x11,0x22,0x02,
    0x10,0x31,0x00,0x10,0xc1,0x50,0x05,0x00,0x12,0x02,0x00,0x44,0x02,0x33,0x21,0x10,
    0x11,0x33,0x21,0x10,0x11,0x33,0x20,0x10,0x21,0x22,0x00,0x55,0x02,0x10,0x55,0x02,
    0x54,0x35,0x40,0x03,0x55,0x00,0x10,0x34,0x02,0x00,0x44,0x00,0x34,0x11,0x1f,0x51,
    0x00,0x10,0x41,0x44,0x00,0x11,0x33,0x03,0x02,0x55,0x01,0x33,0x21,0x50,0x05,0x30,
    0x13,0x02,0x55,0x00,0x33,0x21,0x50,0x05,0x30,0x13,0x02,0x11,0x31,0x03,0x02,0x11,
    0x22,0x02,0x50,0x25,0x00,0x51,0x25,0x40,0x55,0x03,0x34,0x50,0x05,0x00,0x41,0x23,
    0x00,0x40,0x04,0x40,0x13,0xf1,0x11,0x55,0x55,0x50,0x45,0x40,0x55,0x03,0x34,0x55,
    0x03,0x34,0x55,0x03,0x34,0x55,0x03,0x34,0x55,0x04,0x52,0x55,0x00,0x11,0x41,0x44,
    0x00,0x11,0x33,0x03,0x02,0x55,0x01,0x33,0x21,0x50,0x05,0x30,0x13,0x02,0x55,0x00,
    0x11,0x1f,0xf1,0x11,0x54,0x55,0x50,0x45,0x40,0x55,0x03,0x34,0x55,0x03,0x34,0x55,
    0x03,0x34,0x55,0x03,0x34,0x55,0x04,0x52,0x55,0x10,0xf1,0x11,0x1f,0xf1,0x11,0x5b,
    0x35,0x00,0x51,0x25,0x40,0x14,0x55,0x01,0x34,0x13,0x11,0x1f,0xf1,0x11,0x04,0x55,
    0x04,0x04,0x55,0x02,0x34,0x02,0x55,0x00,0x34,0x13,0x02,0x05,0x34,0x13,0x02,0x05,
    0x34,0x13,0x02,0x05,0x34,0x13,0x02,0x55,0x00,0x32,0x02,0x55,0x02,0x02,0x11,0x04,
    0x11,0x2d,0x33,0x22,0x10,0x20,0x22,0x10,0x01,0x05,0x20,0x11,0x1f,0xf1,0x11,0x27,
    0x33,0x22,0x10,0x20,0x22,0x10,0x01,0x05,0x20,0x11,0x1f,0x01,0x55,0x03,0x10,0x55,
    0x02,0x44,0x51,0x15,0x40,0x33,0x51,0x35,0x40,0x53,0x45,0x20,0x55,0x05,0x11,0x1f,
    0xf1,0x11,0x04,0x06,0x7c,0xf4,0xb0,0x11,0x1f,0x51,0x55,0x04,0x00,0x55,0x03,0x44,
    0x50,0x25,0x40,0x33,0x50,0x15,0x40,0x33,0x60,0x55,0x01,0x34,0x36,0x05,0x20,0x33,
    0x01,0x44,0x02,0x33,0x40,0x33,0x22,0x30,0x13,0x36,0x13,0x02,0x63,0x33,0x22,0x30,
    0x43,0x02,0x33,0x24,0x20,0x33,0x22,0x10,0x05,0x20,0x33,0x01,0x44,0x02,0x33,0x40,
    0x33,0x22,0x30,0x13,0x36,0x13,0x02,0x63,0x33,0x22,0x30,0x23,0x00,0x32,0x13,0x40,
    0x24,0x32,0x40,0x33,0x02,0x00,0x34,0x03,0x36,0x03,0x05,0x34,0x36,0x13,0x05,0x34,
    0x33,0x05,0x34,0x33,0x55,0x00,0x32,0x23,0x55,0x01,0x22,0x52,0x25,0x00,0x12,0x61,
    0x03,0x34,0x23,0x02,0x34,0x03,0x36,0x13,0x40,0x63,0x33,0x02,0x34,0x43,0x40,0x33,
    0x04,0x00,0x32,0x23,0x52,0x05,0x20,0x22,0x50,0x15,0x00,0x12,0xf1,0x00,0x12,0x21,
    0x44,0x02,0x11,0x31,0x23,0x02,0x11,0x30,0x36,0x13,0x02,0x61,0x33,0x22,0x10,0x33,
    0x23,0x10,0x03,0x34,0x03,0x40,0x03,0x34,0x03,0x36,0x20,0x40,0x63,0x33,0x01,0x00,
    0x34,0x43,0x40,0x33,0x04,0x00,0x32,0x23,0x52,0x05,0x20,0x22,0x50,0x15,0x00,0x12,
    0xf1,0x55,0x00,0x20,0x11,0x50,0x40,0x24,0x10,0x40,0x33,0x22,0x40,0x33,0x60,0x33,
    0x21,0x34,0x36,0x23,0x42,0x33,0x24,0x34,0x43,0x02,0x32,0x23,0x02,0x10,0x22,0x02,
    0x41,0x04,0x00,0x12,0x01,0x33,0x22,0x10,0x01,0x63,0x33,0x21,0x10,0x36,0x23,0x02,
    0x31,0x33,0x02,0x31,0x33,0x02,0x31,0x23,0x02,0x11,0x20,0x22,0x00,0x10,0x01,0x00,
    0x42,0x04,0x10,0x40,0x33,0x22,0x40,0x33,0x60,0x33,0x21,0x34,0x36,0x23,0x42,0x33,
    0x24,0x11,0x1f,0xd1,0x00,0x12,0x21,0x44,0x02,0x11,0x31,0x23,0x02,0x11,0x30,0x36,
    0x13,0x02,0x61,0x33,0x22,0x10,0x33,0x23,0x10,0x33,0x23,0x10,0x33,0x22,0x50,0x20,
    0x22,0x50,0x40,0x00,0x52,0x40,0x53,0x35,0x40,0x53,0x35,0x40,0x53,0x05,0x40,0x33,
    0x60,0x53,0x05,0x40,0x63,0x33,0x50,0x05,0x40,0x33,0x52,0x05,0x40,0x33,0x52,0x15,
    0x20,0x33,0x51,0x25,0x20,0x12,0x55,0x03,0x10,0x11,0x56,0x05,0x40,0x33,0x60,0x53,
    0x05,0x40,0x63,0x33,0x50,0x05,0x40,0x33,0x52,0x05,0x40,0x33,0x52,0x15,0x20,0x33,
    0x01,0x55,0x01,0x22,0x41,0x50,0x15,0x00,0x31,0x02,0x11,0x5b,0x00,0x12,0x11,0x40,
    0x24,0x10,0x01,0x34,0x23,0x02,0x31,0x03,0x36,0x13,0x02,0x63,0x33,0x22,0x30,0x43,
    0x02,0x33,0x24,0x40,0x33,0x22,0x10,0x33,0x60,0x33,0x21,0x30,0x36,0x23,0x02,0x33,
    0x24,0x30,0x43,0x02,0x32,0x23,0x02,0x01,0x22,0x02,0x11,0x50,0x00,0x12,0x11,0x36,
    0x23,0x02,0x31,0x33,0x02,0x31,0x33,0x02,0x31,0x23,0x02,0x11,0x20,0x22,0x10,0x11,
    0x00,0x12,0xf1,0x11,0x01,0x03,0x00,0x4f,0x81,0xa8,0x52,0x03,0x54,0xf5,0x55,0xf6,
    0x1f,0x53,0xf5,0x55,0x09,0x02,0x34,0xb3,0x83,0x55,0xf6,0x1f,0xf3,0x1f,0xf8,0x1f,
    0xf8,0x1f,0xf8,0x1f,0xf8,0x1f,0x53,0xa5,0xff,0x31,0xff,0x81,0xff,0x81,0xff,0x81,
    0xff,0x81,0x55,0x5f,0x55,0x03,0x54,0xa8,0x52,0xff,0x31,0xff,0x81,0xff,0x81,0xff,
    0x81,0xff,0x81,0xff,0x31,0x55,0x06,
};

#define AES_TEST_IV  {  0x00, 0x01, 0x02, 0x03, \
                        0x04, 0x05, 0x06, 0x07, \
                        0x08, 0x09, 0x0a, 0x0b, \
                        0x0c, 0x0d, 0x0e, 0x0f }
#define AES_TEST_KEY { 0x2b7e1516, 0x28aed2a6, 0xabf71588, 0x09cf4f3c }

static unsigned encrypt(uint8_t *cipherOut, const uint8_t *plainIn, unsigned plainlen);
static unsigned decrypt(uint8_t *plainbuf, const uint8_t *cipherbuf, unsigned cipherlen);

unsigned encrypt(uint8_t *cipherOut, const uint8_t *plainIn, unsigned plainlen)
{
    uint32_t expkey[44];
    const uint32_t key[4] = AES_TEST_KEY;
    AES128::expandKey(expkey, key);

    // cipherBuf holds the cipher in progress - starts with initialization vector
    uint8_t cipherBuf[AES128::BLOCK_SIZE] = AES_TEST_IV;

    uint8_t *cipherstart = cipherOut;

    while (plainlen >= AES128::BLOCK_SIZE) {
        AES128::encryptBlock(cipherBuf, cipherBuf, expkey);

        AES128::xorBlock(cipherBuf, plainIn);
        plainIn += AES128::BLOCK_SIZE;
        
        memcpy(cipherOut, cipherBuf, AES128::BLOCK_SIZE);
        cipherOut += AES128::BLOCK_SIZE;

        plainlen -= AES128::BLOCK_SIZE;
    }

    /*
     * Pad with the number of leftover bytes, PKCS style.
     * Degenerate case is 16-byte aligned - have to do an entire block of nothing but pad
     */

    // assemble the final block - remaining plaintext plus padding
    ASSERT(plainlen < AES128::BLOCK_SIZE);
    uint8_t padvalue = AES128::BLOCK_SIZE - plainlen;
    uint8_t finalBlock[AES128::BLOCK_SIZE];
    memcpy(finalBlock, plainIn, plainlen);
    memset(finalBlock + plainlen, padvalue, padvalue);

    // last block
    AES128::encryptBlock(cipherBuf, cipherBuf, expkey);
    AES128::xorBlock(cipherBuf, finalBlock);
    memcpy(cipherOut, cipherBuf, AES128::BLOCK_SIZE);

    unsigned cipherSize = (cipherOut - cipherstart) + AES128::BLOCK_SIZE;
    ASSERT((cipherSize % AES128::BLOCK_SIZE) == 0 && "bad cipher size");

    return cipherSize;
}

unsigned decrypt(uint8_t *plainbuf, const uint8_t *cipherbuf, unsigned cipherlen)
{
    uint32_t expkey[44];
    const uint32_t key[4] = AES_TEST_KEY;
    AES128::expandKey(expkey, key);

    // cipherBuf holds the cipher in progress - starts with initialization vector
    uint8_t cipher[AES128::BLOCK_SIZE] = AES_TEST_IV;
    uint8_t *plainstart = plainbuf;

    while (cipherlen > AES128::BLOCK_SIZE) {
        AES128::encryptBlock(plainbuf, cipher, expkey);

        memcpy(cipher, cipherbuf, AES128::BLOCK_SIZE);
        cipherbuf += AES128::BLOCK_SIZE;
        cipherlen -= AES128::BLOCK_SIZE;

        AES128::xorBlock(plainbuf, cipher);
        plainbuf += AES128::BLOCK_SIZE;
    }

    // assume the ciphertext was padded, so should always be block aligned
    ASSERT(cipherlen == AES128::BLOCK_SIZE && "bad pad size");

    // output of the last cipher is run through the encryption block
    AES128::encryptBlock(plainbuf, cipher, expkey);
    memcpy(cipher, cipherbuf, AES128::BLOCK_SIZE);
    // XXX: slightly bogus to expect there to be a full block available at plainbuf
    // to write into here, but would require an additional copy otherwise
    AES128::xorBlock(plainbuf, cipher);

    // look for pad value at the end of the last block
    uint8_t padvalue = plainbuf[15];
    ASSERT(padvalue <= AES128::BLOCK_SIZE);

    unsigned lastBlockPlainSize = AES128::BLOCK_SIZE - padvalue;
    // verify that all the padded bytes are the pad value (PKCS)
    uint8_t *p = plainbuf + lastBlockPlainSize;
    for (unsigned i = 0; i < padvalue; ++i)
        ASSERT(p[i] == padvalue);

    return plainbuf - plainstart + lastBlockPlainSize;
}

static void roundtrip()
{
    uint8_t cipherbuf[sizeof(testdata) + AES128::BLOCK_SIZE];

    unsigned cipherlen = encrypt(cipherbuf, testdata, sizeof testdata);
    ASSERT(cipherlen >= sizeof testdata);
    
    uint8_t decryptbuf[sizeof cipherbuf];
    unsigned decryptlen = decrypt(decryptbuf, cipherbuf, cipherlen);

    ASSERT(decryptlen == sizeof testdata);
    ASSERT(memcmp(decryptbuf, testdata, sizeof testdata) == 0);
}

int main()
{
    roundtrip();
    
    LOG(("aes128: Success.\n"));
    return 0;
}

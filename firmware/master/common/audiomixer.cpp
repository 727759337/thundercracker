/*
 * Thundercracker Firmware -- Confidential, not for redistribution.
 * Copyright <c> 2012 Sifteo, Inc. All rights reserved.
 */

#include "audiomixer.h"
#include "audiooutdevice.h"
#include "flash_blockcache.h"
#include <stdio.h>
#include <string.h>
#include <limits.h>
#include "xmtrackerplayer.h"
#include "volume.h"

#ifdef SIFTEO_SIMULATOR
#   include "system.h"
#   include "system_mc.h"
#   include "mc_audiovisdata.h"
#else
#   include "sampleprofiler.h"
#endif

// Lookup table generated by tools/firmware-audiolimit-table.py
#include "audiolimit-table.def"


AudioMixer AudioMixer::instance;
AudioMixer::OutputBuffer AudioMixer::output;


AudioMixer::AudioMixer() :
    trackerCallbackInterval(0),
    trackerCallbackCountdown(0),
    playingChannelMask(0)
{}

void AudioMixer::init()
{
    output.init();
    limiterPeak = 0;

    uint32_t mask = playingChannelMask;
    while (mask) {
        unsigned idx = Intrinsic::CLZ(mask);
        mask &= ~Intrinsic::LZ(idx);

        if (idx >= _SYS_AUDIO_MAX_CHANNELS) {
            ASSERT(idx < _SYS_AUDIO_MAX_CHANNELS);
            continue;
        }

        AudioChannelSlot &ch = channelSlots[idx];

        ch.stop();
    }

    XmTrackerPlayer::instance.init();
}

ALWAYS_INLINE bool AudioMixer::mixAudio(int *buffer, uint32_t numFrames)
{
    /*
     * Mix audio from flash into the audio device's buffer via each of the channels.
     *
     * This currently assumes that it's being run on the main thread, such that it
     * can operate synchronously with data arriving from flash.
     *
     * Returns true if any audio data was available. If so, we're guaranteed
     * to produce exactly 'numFrames' of data.
     *
     * Assumes the buffer was already zero'ed. Each channel is mixed together
     * into the same buffer.
     *
     * If buffer is NULL, we update the state of all channels without
     * actually generating any audio data.
     */
    
    bool result = false;

    uint32_t mask = playingChannelMask;
    while (mask) {
        unsigned idx = Intrinsic::CLZ(mask);
        mask ^= Intrinsic::LZ(idx);
        ASSERT(idx < _SYS_AUDIO_MAX_CHANNELS);

        AudioChannelSlot &ch = channelSlots[idx];

        if (ch.isStopped()) {
            Atomic::ClearLZ(playingChannelMask, idx);
            continue;
        }
        if (ch.isPaused()) {
            continue;
        }
        
        // Each channel individually mixes itself with the existing buffer contents
        result |= ch.mixAudio(buffer, numFrames);
    }
    
    return result;
}

ALWAYS_INLINE int16_t AudioMixer::softLimiter(int32_t sample, int32_t &peak)
{
    /*
     * This is a stateful soft limiter.
     *
     * We use 'peak' as a leaky peak tracker, to keep track of the actual maximum
     * volume level we've seen. This has an infinitely sharp attack as new peaks occur,
     * and a slower decay as the audio power decreases.
     *
     * This peak value controls the gain of a variable attenuator. Normally the gain
     * is 1, meaning that we pass the signal through unmodified. If the peak crosses
     * a threshold, we start to ease the gain downward according to a nonlinear curve.
     *
     * This curve is calculated ahead-of-time by tools/firmware-audiolimit-table.py
     */

    // Decay rate for the peak tracker. 0x10000 is infinite sustain, 0x0000 is immediate decay.
    const int decay = 0xfd00;

    // Peak tracker
    int absSample = sample < 0 ? -sample : sample;
    peak = (decay * peak) >> 16;
    if (absSample > peak) {
        peak = absSample;
    }

    /*
     * Convert peak to a 24:8 fixed-point value representing an index in our lookup table.
     * We want to scale peak from the range [0, 0x8000 * AudioLimitMaxPeak] to the range
     * [0, AudioLimitSteps * 256]. We need to be careful about overflow, and we can take
     * advantage of the fact that all of these values are powers of two. This will optimize
     * down to a single right shift.
     */
    const int scaleNumerator = AudioLimitSteps * 256;
    const int scaleDenominator = 0x8000 * AudioLimitMaxPeak;
    STATIC_ASSERT(scaleNumerator > 0);
    STATIC_ASSERT(scaleDenominator >= scaleNumerator);
    STATIC_ASSERT((scaleNumerator & (scaleNumerator - 1)) == 0);
    STATIC_ASSERT((scaleDenominator & (scaleDenominator - 1)) == 0);
    int fpIndex = peak / (scaleDenominator / scaleNumerator);
    int index = fpIndex >> 8;

    STATIC_ASSERT(arraysize(AudioLimitTable) == AudioLimitSteps);
    int gain;

    if (LIKELY(index < (AudioLimitSteps - 1))) {
        // Fully inside our table; linear interpolate

        int fraction = fpIndex & 0xFF;
        int y1 = AudioLimitTable[index];
        int y2 = AudioLimitTable[index + 1];

        // Early out for unity gain
        if (LIKELY(y2 == 0xFFFF)) {
            return sample;
        }

        gain = (y1 * (0x100 - fraction) + y2 * fraction) >> 8;

    } else {
        // Past the end of our table; extrapolate using the last two samples

        int fraction = fpIndex - ((AudioLimitSteps - 2) * 256);
        int y1 = AudioLimitTable[AudioLimitSteps - 2];
        int y2 = AudioLimitTable[AudioLimitSteps - 1];

        gain = ((y2 - y1) * fraction) >> 8;
    }

    ASSERT(gain >= 0);
    int attenuated = (sample * gain) >> 16;

    ASSERT(attenuated >= -0x8000);
    ASSERT(attenuated <=  0x7FFF);
    return attenuated;
}

/*
 * Called from within Tasks::work to mix audio on the main thread, to be
 * consumed by the audio out device.
 */
void AudioMixer::pullAudio()
{
    /*
     * Support audio in Siftulator, even in headless mode.
     *
     * In headless mode, we want to continue mixing even though
     * there's no buffer attached or no space in that buffer. We'll
     * either discard the mixed data, or if a waveout file is set we'll
     * end up logging the mixed audio data.
     */

    #ifdef SIFTEO_SIMULATOR
        const bool headless = SystemMC::getSystem()->opt_headless;
    #else
        const bool headless = false;
    #endif

    /*
     * Early out when we can quickly determine that no channels are playing
     * and the tracker is idle.
     *
     * Note that in headless mode, we have no audio driver to wake up our
     * task, we're polling based on wallclock time: so we constantly re-trigger
     * our own task. In other modes, we do NOT do this. We only wake up when
     * the audio driver has dequeued some samples.
     */

    #ifdef SIFTEO_SIMULATOR
        if (headless) {
            Tasks::trigger(Tasks::AudioPull);
        }
    #endif

    #ifdef SIFTEO_SIMULATOR
        MCAudioVisData::instance.mixerActive = AudioMixer::instance.active();
    #endif

    if (!AudioMixer::instance.active()) {

        // must give simulated audio device a chance to pull any
        // data already in the mix buffer, even if all channels have emptied
        if (!headless) {
            AudioOutDevice::pullFromMixer();
        }

        if (AudioMixer::instance.trackerCallbackInterval == 0)
            return;
    }

    /*
     * In order to amortize the cost of iterating over channels, our
     * audio mixer operates on small arrays of samples at a time. We
     * give it a tiny buffer on the stack, which then flushes out
     * to the device's provided AudioBuffer.
     *
     * We're responsible for invoking the Tracker's callback
     * deterministically, exactly every 'trackerInterval' samples.
     * To do this, we may need to subdivide the blocks we request
     * from mixAudio(), or we may need to generate silent blocks.
     *
     * We refuse to pull (exiting early) if there are too few samples
     * to mix, so that we don't destroy our amortization gains by
     * mixing one sample at a time.
     */

    int blockBuffer[32];
    unsigned samplesLeft = output.writeAvailable();

    #ifdef SIFTEO_SIMULATOR
        if (headless) {
            samplesLeft = SystemMC::suggestAudioSamplesToMix();
        }
    #endif

    if (samplesLeft < arraysize(blockBuffer)) {
        // Need more room in the buffer before we can mix!
        if (!headless)
            AudioOutDevice::pullFromMixer();
        return;
    }

    #ifndef SIFTEO_SIMULATOR
        SampleProfiler::SubSystem s = SampleProfiler::subsystem();
        SampleProfiler::setSubsystem(SampleProfiler::AudioPull);
    #endif

    const uint32_t trackerInterval = AudioMixer::instance.trackerCallbackInterval;
    uint32_t trackerCountdown;

    if (trackerInterval == 0) {
        // Tracker callbacks disabled. Avoid special-casing below by
        // assuming a countdown value that's effectively infinite.
        trackerCountdown = 0x10000;
    } else {
        trackerCountdown = AudioMixer::instance.trackerCallbackCountdown;
        ASSERT(trackerCountdown != 0 && "Countdown should never be stored as zero when the timer is enabled");
    } 

    // Calculating volume is relatively expensive; do it only if we have audio to mix.
    const int mixerVolume = Volume::systemVolume();
    ASSERT(mixerVolume >= 0 && mixerVolume <= Volume::MAX_VOLUME);

    #ifdef SIFTEO_SIMULATOR
        /*
         * Reserve one slot for an end-of-stream token in simulation.
         * Because the mix loop may continue after the stream has ended
         * (ie, to keep ticking the tracker's clock), ensure we only
         * send the first end-of-stream that we see.
         */
        samplesLeft--;
        bool endOfStreamSet = false;
    #endif

    // Local buffer for limiter state, for more efficient inlining.
    int32_t localLimiterPeak = AudioMixer::instance.limiterPeak;

    do {
        bool mixed;
        uint32_t blockSize = MIN(arraysize(blockBuffer), samplesLeft);
        blockSize = MIN(blockSize, trackerCountdown);
        ASSERT(blockSize > 0);

        if (mixerVolume) {
            // Not muted. Generate audio data

            // Zero out the buffer (Faster than memset)
            for (int *i = blockBuffer, *e = blockBuffer + blockSize; i != e; ++i)
                *i = 0;

            // Mix data from all channels.
            mixed = AudioMixer::instance.mixAudio(blockBuffer, blockSize);
    
        } else {
            /*  
             * Disable mixing if the output is muted, both to save a little power
             * and to make audio performance bugs easier to diagnose.
             *
             * We still need to go into each channel's mixer in order to update
             * channel state, but this inhibits the expensive decompression and
             * mixing operations from occurring.
             */

            AudioMixer::instance.mixAudio(0, blockSize);
            mixed = false;
        }

        /*
         * The mixer had nothing for us? Normally this means
         * we can early-out and let the device's buffer drain,
         * but if we're running the tracker, we need to keep
         * samples flowing in order to keep its clock advancing.
         * Generate silence.
         */
        if (!mixed) {

            #ifdef SIFTEO_SIMULATOR
            if (!headless) {
                if (!endOfStreamSet) {
                    output.enqueue(AudioOutDevice::END_OF_STREAM);
                    endOfStreamSet = true;
                }
            }
            #endif

            if (trackerInterval == 0)
                break;
        }

        trackerCountdown -= blockSize;
        samplesLeft -= blockSize;

        /*
         * Finish mixing our block of audio, by applying the system-wide
         * volume control and clamping to 16 bits.
         *
         * We do this even if muted (as long as tracker audio is running)
         * so there's a consistent time-base, based on the audio clock's
         * rate of consuming silent samples.
         */

        int *ptr = blockBuffer;
        do {
            /*
             * In one step, this does a fixed-point multiply with the mixer volume and by
             * the overall mixer gain constant. The result is a 32-bit signed value.
             */
            int sample = (*(ptr++) * (mixerVolume >> 1))
                >> (Volume::MAX_VOLUME_LOG2 - 1 - Volume::MIXER_GAIN_LOG2);

            // Use the soft limiter to convert back to 16-bit samples.
            int16_t sample16 = softLimiter(sample, localLimiterPeak);

            #ifdef SIFTEO_SIMULATOR
                // Log audio for --waveout
                SystemMC::logAudioSamples(&sample16, 1);
            #endif

            if (!headless) {
                output.enqueue(sample16);
            }
        } while (--blockSize);

        if (!trackerCountdown) {
            ASSERT(trackerInterval);
            trackerCountdown = trackerInterval;
            XmTrackerPlayer::mixerCallback();
        }

    } while (samplesLeft);

    if (trackerInterval != 0) {
        // Write back local copy of Countdown, only if it's real.
        AudioMixer::instance.trackerCallbackCountdown = trackerCountdown;
    }

    // Write back locally cached state
    AudioMixer::instance.limiterPeak = localLimiterPeak;

    // Give the output a chance to dequeue data immediately (Only used on Siftulator)
    if (!headless)
        AudioOutDevice::pullFromMixer();

    #ifndef SIFTEO_SIMULATOR
        SampleProfiler::setSubsystem(s);
    #endif
}

bool AudioMixer::play(const struct _SYSAudioModule *mod,
    _SYSAudioChannelID ch, _SYSAudioLoopType loopMode)
{
    // NB: "mod" is a temporary contiguous copy of _SYSAudioModule in RAM.

    // Invalid channel?
    if (ch >= _SYS_AUDIO_MAX_CHANNELS) {
        ASSERT(ch < _SYS_AUDIO_MAX_CHANNELS);
        return false;
    }

    // Already playing?
    if (isPlaying(ch))
        return false;

    AudioChannelSlot &slot = channelSlots[ch];
    slot.play(mod, loopMode);
    Atomic::SetLZ(playingChannelMask, ch);

    return true;
}

bool AudioMixer::isPlaying(_SYSAudioChannelID ch) const
{
    // Invalid channel?
    if (ch >= _SYS_AUDIO_MAX_CHANNELS) {
        ASSERT(ch < _SYS_AUDIO_MAX_CHANNELS);
        return false;
    }

    return (playingChannelMask & Intrinsic::LZ(ch)) != 0;
}

void AudioMixer::stop(_SYSAudioChannelID ch)
{
    // Invalid channel?
    if (ch >= _SYS_AUDIO_MAX_CHANNELS) {
        ASSERT(ch < _SYS_AUDIO_MAX_CHANNELS);
        return;
    }

    channelSlots[ch].stop();
    Atomic::ClearLZ(playingChannelMask, ch);

    #ifdef SIFTEO_SIMULATOR
        MCAudioVisData::clearChannel(ch);
    #endif
}

void AudioMixer::pause(_SYSAudioChannelID ch)
{
    // Invalid channel?
    if (ch >= _SYS_AUDIO_MAX_CHANNELS) {
        ASSERT(ch < _SYS_AUDIO_MAX_CHANNELS);
        return;
    }

    if (isPlaying(ch)) {
        channelSlots[ch].pause();
    }

    #ifdef SIFTEO_SIMULATOR
        MCAudioVisData::clearChannel(ch);
    #endif
}

void AudioMixer::resume(_SYSAudioChannelID ch)
{
    // Invalid channel?
    if (ch >= _SYS_AUDIO_MAX_CHANNELS) {
        ASSERT(ch < _SYS_AUDIO_MAX_CHANNELS);
        return;
    }

    if (isPlaying(ch)) {
        channelSlots[ch].resume();
    }
}

void AudioMixer::setVolume(_SYSAudioChannelID ch, uint16_t volume)
{
    // Invalid channel?
    if (ch >= _SYS_AUDIO_MAX_CHANNELS) {
        ASSERT(ch < _SYS_AUDIO_MAX_CHANNELS);
        return;
    }

    channelSlots[ch].setVolume(volume);
}

int AudioMixer::volume(_SYSAudioChannelID ch) const
{
    // Invalid channel?
    if (ch >= _SYS_AUDIO_MAX_CHANNELS) {
        ASSERT(ch < _SYS_AUDIO_MAX_CHANNELS);
        return -1;
    }

    return channelSlots[ch].volume;
}

void AudioMixer::setSpeed(_SYSAudioChannelID ch, uint32_t samplerate)
{
    // Invalid channel?
    if (ch >= _SYS_AUDIO_MAX_CHANNELS) {
        ASSERT(ch < _SYS_AUDIO_MAX_CHANNELS);
        return;
    }

    channelSlots[ch].setSpeed(samplerate);
}

void AudioMixer::setPos(_SYSAudioChannelID ch, uint32_t ofs)
{
    // Invalid channel?
    if (ch >= _SYS_AUDIO_MAX_CHANNELS) {
        ASSERT(ch < _SYS_AUDIO_MAX_CHANNELS);
        return;
    }

    channelSlots[ch].setPos(ofs);
}

uint32_t AudioMixer::pos(_SYSAudioChannelID ch) const
{
    // Invalid channel?
    if (ch >= _SYS_AUDIO_MAX_CHANNELS) {
        ASSERT(ch < _SYS_AUDIO_MAX_CHANNELS);
        return (uint32_t)-1;
    }

    // TODO - implement
    return 0;
}

void AudioMixer::setLoop(_SYSAudioChannelID ch, _SYSAudioLoopType loopMode)
{
    // Invalid channel?
    if (ch >= _SYS_AUDIO_MAX_CHANNELS) {
        ASSERT(ch < _SYS_AUDIO_MAX_CHANNELS);
        return;
    }

    channelSlots[ch].setLoop(loopMode);
}

void AudioMixer::setTrackerCallbackInterval(uint32_t usec)
{
    static const uint64_t kMicroSecondsPerSecond = 1000000;

    // Convert to frames
    trackerCallbackInterval = ((uint64_t)usec * (uint64_t)SAMPLE_HZ) / kMicroSecondsPerSecond;

    // Catch underflow. No one should ever need callbacks this often. Ever.
    ASSERT(usec == 0 || trackerCallbackInterval > 0);
    // But if we're not DEBUG, we may as well let it happen every sample. Gross.
    if (usec > 0 && trackerCallbackInterval == 0) {
        trackerCallbackInterval = 1;
    }

    trackerCallbackCountdown = trackerCallbackInterval;
}

/* -*- mode: C; c-basic-offset: 4; intent-tabs-mode: nil -*-
 *
 * Sifteo prototype simulator
 * M. Elizabeth Scott <beth@sifteo.com>
 *
 * Copyright <c> 2011 Sifteo, Inc. All rights reserved.
 */

#ifdef _WIN32
#   define WIN32_LEAN_AND_MEAN
#   include <windows.h>
#   pragma comment(lib, "opengl32.lib")
#endif

#include <stdint.h>
#include <SDL.h>
#include <GL/gl.h>

#include "emu8051.h"
#include "emulator.h"
#include "frontend.h"
#include "lcd.h"
#include "adc.h"

#ifndef GL_UNSIGNED_SHORT_5_6_5
#   define GL_UNSIGNED_SHORT_5_6_5 0x8363
#endif

#define PROFILER_BYTES  16384
#define PROFILER_LINES  (PROFILER_BYTES / LCD_WIDTH)

// Generated by heatpalette.py
static const uint16_t heatpalette[] = {
    0x0019, 0x0019, 0x0039, 0x0039, 0x0039, 0x0059, 0x0059, 0x0079,
    0x0079, 0x007a, 0x009a, 0x009a, 0x00ba, 0x00ba, 0x00ba, 0x00da,
    0x00da, 0x00fa, 0x00fa, 0x011a, 0x011a, 0x013a, 0x013a, 0x013a,
    0x015a, 0x015b, 0x017b, 0x017b, 0x019b, 0x019b, 0x01bb, 0x01bb,
    0x01bb, 0x01db, 0x01db, 0x01fb, 0x01fb, 0x021b, 0x021b, 0x023b,
    0x023b, 0x025c, 0x025c, 0x027c, 0x027c, 0x029c, 0x029c, 0x02bc,
    0x02bc, 0x02dc, 0x02dc, 0x02fc, 0x02fc, 0x031c, 0x031c, 0x033c,
    0x033c, 0x035d, 0x035d, 0x037d, 0x037d, 0x039d, 0x039d, 0x03bd,
    0x03bd, 0x03dd, 0x03dd, 0x03fd, 0x03fd, 0x041d, 0x041d, 0x043d,
    0x045d, 0x045e, 0x047e, 0x047e, 0x049e, 0x049e, 0x04be, 0x04be,
    0x04de, 0x04de, 0x04fe, 0x051e, 0x051e, 0x053e, 0x053e, 0x055e,
    0x055e, 0x057f, 0x059f, 0x059f, 0x05bf, 0x05bf, 0x05df, 0x05df,
    0x05ff, 0x061f, 0x061f, 0x063f, 0x063f, 0x065f, 0x067f, 0x067f,
    0x069f, 0x069f, 0x06bf, 0x06bf, 0x06df, 0x06df, 0x06ff, 0x06ff,
    0x071f, 0x071f, 0x073f, 0x073f, 0x075f, 0x075f, 0x077f, 0x0f7f,
    0x0f9f, 0x0f9f, 0x0fbf, 0x0fbf, 0x0fdf, 0x0fdf, 0x0fff, 0x0fff,
    0x0fff, 0x0fff, 0x0fff, 0x0fff, 0x0ffe, 0x0ffe, 0x0ffe, 0x17fe,
    0x17fd, 0x17fd, 0x17fd, 0x17fd, 0x17fc, 0x17fc, 0x17fc, 0x17fc,
    0x17fc, 0x17fb, 0x17fb, 0x17fb, 0x17fb, 0x17fa, 0x17fa, 0x1ffa,
    0x1ffa, 0x1ffa, 0x1ff9, 0x1ff9, 0x1ff9, 0x1ff9, 0x1ff9, 0x1ff8,
    0x1ff8, 0x1ff8, 0x1ff8, 0x1ff8, 0x1ff7, 0x1ff7, 0x1ff7, 0x27f7,
    0x27f7, 0x27f6, 0x27f6, 0x27f6, 0x27f6, 0x27f6, 0x27f5, 0x27f5,
    0x27f5, 0x27f5, 0x27f5, 0x27f4, 0x27f4, 0x27f4, 0x27f4, 0x2ff4,
    0x2ff4, 0x2ff3, 0x2ff3, 0x2ff3, 0x2ff3, 0x2ff3, 0x2ff2, 0x2ff2,
    0x2ff2, 0x2ff2, 0x2ff2, 0x2ff2, 0x2ff1, 0x2ff1, 0x2ff1, 0x37f1,
    0x37f1, 0x37f1, 0x37f0, 0x37f0, 0x37f0, 0x37f0, 0x37f0, 0x37f0,
    0x37ef, 0x37ef, 0x37ef, 0x37ef, 0x37ef, 0x37ef, 0x37ef, 0x3fee,
    0x3fee, 0x3fee, 0x3fee, 0x3fee, 0x3fee, 0x3fed, 0x3fed, 0x3fed,
    0x3fed, 0x3fed, 0x3fed, 0x3fed, 0x3fec, 0x3fec, 0x3fec, 0x47ec,
    0x47ec, 0x47ec, 0x47ec, 0x47ec, 0x47eb, 0x47eb, 0x47eb, 0x47eb,
    0x47eb, 0x47eb, 0x47eb, 0x47ea, 0x47ea, 0x47ea, 0x47ea, 0x4fea,
    0x4fea, 0x4fea, 0x4fea, 0x4fea, 0x4fe9, 0x4fe9, 0x4fe9, 0x4fe9,
    0x4fe9, 0x4fe9, 0x57e9, 0x57e9, 0x57e9, 0x57e9, 0x5fe9, 0x5fea,
    0x5fea, 0x5fea, 0x67ea, 0x67ea, 0x67ea, 0x67ea, 0x67ea, 0x6fea,
    0x6fea, 0x6fea, 0x6fea, 0x77ea, 0x77ea, 0x77ea, 0x77ea, 0x77eb,
    0x7feb, 0x7feb, 0x7feb, 0x7feb, 0x7feb, 0x87eb, 0x87eb, 0x87eb,
    0x87eb, 0x87eb, 0x8feb, 0x8feb, 0x8feb, 0x8feb, 0x8feb, 0x97ec,
    0x97ec, 0x97ec, 0x97ec, 0x97ec, 0x9fec, 0x9fec, 0x9fec, 0x9fec,
    0x9fec, 0xa7ec, 0xa7ec, 0xa7ec, 0xa7ec, 0xa7ec, 0xafec, 0xafed,
    0xafed, 0xafed, 0xafed, 0xafed, 0xb7ed, 0xb7ed, 0xb7ed, 0xb7ed,
    0xb7ed, 0xbfed, 0xbfed, 0xbfed, 0xbfed, 0xbfed, 0xbfed, 0xc7ee,
    0xc7ee, 0xc7ee, 0xc7ee, 0xc7ee, 0xc7ee, 0xcfee, 0xcfee, 0xcfee,
    0xcfee, 0xcfee, 0xcfee, 0xcfee, 0xd7ee, 0xd7ee, 0xd7ee, 0xd7ef,
    0xd7ef, 0xd7ef, 0xdfef, 0xdfef, 0xdfef, 0xdfef, 0xdfef, 0xdfef,
    0xdfef, 0xe7ef, 0xe7ef, 0xe7ef, 0xe7ef, 0xe7ef, 0xe7ef, 0xe7f0,
    0xeff0, 0xeff0, 0xeff0, 0xeff0, 0xeff0, 0xeff0, 0xeff0, 0xeff0,
    0xf7f0, 0xf7f0, 0xf7f0, 0xf7f0, 0xf7f0, 0xf7f0, 0xf7f0, 0xf7f1,
    0xfff1, 0xfff1, 0xfff1, 0xfff1, 0xfff1, 0xfff1, 0xfff1, 0xfff1,
    0xfff1, 0xfff1, 0xfff1, 0xffd1, 0xffd1, 0xffd1, 0xffd1, 0xffd2,
    0xffb2, 0xffb2, 0xffb2, 0xffb2, 0xffb2, 0xff92, 0xff92, 0xff92,
    0xff92, 0xff92, 0xff72, 0xff72, 0xff72, 0xff72, 0xff72, 0xff53,
    0xff53, 0xff53, 0xff53, 0xff53, 0xff53, 0xff33, 0xff33, 0xff33,
    0xff33, 0xff33, 0xff33, 0xff13, 0xff13, 0xff13, 0xff13, 0xff14,
    0xff14, 0xff14, 0xfef4, 0xfef4, 0xfef4, 0xfef4, 0xfef4, 0xfef4,
    0xfef4, 0xfed4, 0xfed4, 0xfed4, 0xfed4, 0xfed4, 0xfed4, 0xfed5,
    0xfed5, 0xfed5, 0xfeb5, 0xfeb5, 0xfeb5, 0xfeb5, 0xfeb5, 0xfeb5,
    0xfeb5, 0xfeb5, 0xfeb5, 0xfeb5, 0xfe95, 0xfe95, 0xfe95, 0xfe96,
    0xfe96, 0xfe96, 0xfe96, 0xfe96, 0xfe96, 0xfe96, 0xfe96, 0xfe96,
    0xfe76, 0xfe76, 0xfe76, 0xfe76, 0xfe76, 0xfe76, 0xfe76, 0xfe77,
    0xfe77, 0xfe77, 0xfe77, 0xfe77, 0xfe77, 0xfe77, 0xfe77, 0xfe77,
    0xfe77, 0xfe77, 0xfe77, 0xfe77, 0xfe77, 0xfe77, 0xfe57, 0xfe58,
    0xfe58, 0xfe58, 0xfe58, 0xfe58, 0xfe58, 0xfe58, 0xfe58, 0xfe58,
    0xfe58, 0xfe58, 0xfe58, 0xfe58, 0xfe58, 0xfe58, 0xfe58, 0xfe59,
    0xfe59, 0xfe59, 0xfe59, 0xfe59, 0xfe59, 0xfe59, 0xfe59, 0xfe79,
};

static struct {
    SDL_Surface *surface;
    struct em8051 *cpu;
    int frame_hz_divisor;
    int profiler_div_timer;
    int running;
    int scale;
} frontend;


static uint64_t clamp64(uint64_t val, uint64_t min, uint64_t max)
{
    if (val < min) val = min;
    if (val > max) val = max;
    return val;
}

static uint32_t clamp32(uint32_t val, uint32_t min, uint32_t max)
{
    if (val < min) val = min;
    if (val > max) val = max;
    return val;
}

static void frontend_update_profiler(uint16_t *dest)
{
    static uint64_t shadow[PROFILER_BYTES];
    uint64_t *profiler, *shadow_p;
    uint64_t max_count = 0;

    // First pass, look for the maximum count
    for (shadow_p = shadow, profiler = frontend.cpu->mProfilerMem;
         shadow_p < shadow + PROFILER_BYTES; shadow_p++, profiler++) {
    	uint64_t count = *profiler - *shadow_p;
        if (count > max_count)
            max_count = count;
    }

    // Second pass, draw the map
    for (shadow_p = shadow, profiler = frontend.cpu->mProfilerMem;
         shadow_p < shadow + PROFILER_BYTES; shadow_p++, profiler++) {
	uint64_t count = *profiler - *shadow_p;
        uint16_t pixel;

        if (count)
            pixel = heatpalette[count * (sizeof heatpalette / sizeof heatpalette[0] - 1) / max_count];
        else
            pixel = 0;

	*shadow_p = *profiler; 
	*(dest++) = pixel;		    
    }
}

static void frontend_update_texture(void)
{
    uint16_t *fb = lcd_framebuffer();
    GLsizei width = LCD_WIDTH;
    GLsizei height = LCD_HEIGHT;

    if (opt_visual_profiler) {       
        // Update the profiler only every N frames
        if (++frontend.profiler_div_timer >= 3) {
            frontend.profiler_div_timer = 0;
	    frontend_update_profiler(fb + (LCD_WIDTH * LCD_HEIGHT));
        }

        height += PROFILER_LINES;
    }

    glTexImage2D(GL_TEXTURE_2D, 0, 3, width, height, 0, GL_RGB,
		 GL_UNSIGNED_SHORT_5_6_5, fb);
}

static void frontend_draw_frame(void)
{
    static const GLfloat vertexArray[] = {
	0, 1,  -1,-1, 0,
	1, 1,   1,-1, 0,
	0, 0,  -1, 1, 0,
	1, 0,   1, 1, 0,
    };

    glInterleavedArrays(GL_T2F_V3F, 0, vertexArray);
    glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);

    SDL_GL_SwapBuffers();
}

static void frontend_resize_window(void)
{
    unsigned width = LCD_WIDTH;
    unsigned height = LCD_HEIGHT;

    if (opt_visual_profiler)
	height += PROFILER_LINES;

    width *= frontend.scale;
    height *= frontend.scale;
    
    frontend.surface = SDL_SetVideoMode(width, height, 16, SDL_OPENGL);
    if (frontend.surface == NULL) {
	printf("Error creating SDL surface!\n");
	exit(1);
    }

    SDL_GL_SetAttribute(SDL_GL_SWAP_CONTROL, 1);

    glViewport(0, 0, width, height);

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();

    glDisable(GL_LIGHTING);
    glDisable(GL_DEPTH_TEST);
    glDisable(GL_CULL_FACE);

    glEnable(GL_TEXTURE_2D);
    glShadeModel(GL_SMOOTH);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);

    frontend_update_texture();
    frontend_draw_frame();
}

static uint16_t frontend_scale_coord(uint32_t coord, uint16_t width)
{
    /*
     * Convert a pixel coordinate to a normalized value in the range
     * [0, 0xFFFF], with proper rounding and boundary condition
     * handling.
     */
    uint32_t max_coord = width - 1;
    return clamp32(0, 0xFFFF, (coord * 0xFFFF + max_coord / 2) / max_coord);
}

static void frontend_mouse_update(uint16_t x, uint16_t y, uint8_t buttons)
{
    uint16_t scaled_x = frontend_scale_coord(x, frontend.scale * LCD_WIDTH);
    uint16_t scaled_y = frontend_scale_coord(y, frontend.scale * LCD_HEIGHT);

    uint16_t accel_x = 0x8000;
    uint16_t accel_y = 0x8000;

    if (buttons & SDL_BUTTON_LEFT) {
	// Mouse drag: Simulate a tilt
	accel_x = scaled_x;
	accel_y = scaled_y;
    }

    adc_set_input(0, accel_x);
    adc_set_input(1, accel_y);
}

void frontend_init(struct em8051 *cpu)
{
    SDL_Init(SDL_INIT_VIDEO);
    frontend.running = 1;
    frontend.scale = 2;
    frontend.cpu = cpu;

    // XXX: Assuming 60Hz host display, 30Hz emulated rate
    frontend.frame_hz_divisor = 2;

    frontend_resize_window();
    frontend_mouse_update(0, 0, 0);
    SDL_WM_SetCaption("Thundercracker", NULL);
}

void frontend_exit(void)
{
    SDL_Quit();
}

static void frontend_keydown(SDL_KeyboardEvent *evt)
{
    switch (evt->keysym.sym) {

	// Change scale
    case 's':
	if (++frontend.scale == 6)
	    frontend.scale = 1;
	frontend_resize_window();
	break;

	// Toggle profiler
    case 'p':
	opt_visual_profiler = !opt_visual_profiler;
	frontend_resize_window();
	break;

    }
}

void frontend_loop(void)
{
    while (frontend.running) {
	SDL_Event event;
    
	// Drain the GUI event queue
	while (SDL_PollEvent(&event)) {
	    switch (event.type) {
		
	    case SDL_QUIT:
		frontend_async_quit();
		break;

	    case SDL_KEYDOWN:
		frontend_keydown(&event.key);
		break;

	    case SDL_MOUSEMOTION:
		frontend_mouse_update(event.motion.x, event.motion.y, event.motion.state);
		break;

	    case SDL_MOUSEBUTTONDOWN:
	    case SDL_MOUSEBUTTONUP:
		frontend_mouse_update(event.button.x, event.button.y, event.button.state);
		break;
	    
	    }
	}

	if (frontend.running) {
            int i;
            
            frontend_update_texture();
	    lcd_te_pulse();
            
            for (i = 0; i < frontend.frame_hz_divisor; i++)
	        frontend_draw_frame();
	}
    }
}

void frontend_async_quit(void)
{
    frontend.running = 0;
}

# implementation of sandwich kingdom content specification

import lxml.etree
import os
import os.path
import re
import tmx
import misc

# constants
PORTAL_OPEN = 0
PORTAL_WALLED = 1
PORTAL_DOOR = 2
PORTAL_LABELS = [ "PORTAL_OPEN", "PORTAL_WALL", "PORTAL_DOOR" ]
SIDE_TOP = 0
SIDE_LEFT = 1
SIDE_BOTTOM = 2
SIDE_RIGHT = 3
EXP_REGULAR = re.compile(r"^([a-z]+)$")
EXP_PLUS = re.compile(r"^([a-z]+)\+(\d+)$")
EXP_MINUS = re.compile(r"^([a-z]+)\-(\d+)$")
EXP_GATEWAY = re.compile(r"^(\w+):(\w+)$")
TRIGGER_GATEWAY = 0
TRIGGER_ITEM = 1
TRIGGER_NPC = 2
KEYWORD_TO_TRIGGER_TYPE = {
	"gateway": TRIGGER_GATEWAY,
	"item": TRIGGER_ITEM,
	"npc": TRIGGER_NPC
}

def load():
	return World(".")

def export():
	World(".").export()

class World:
	def __init__(self, dir):
		self.dir = dir
		self.script = GameScript(self, os.path.join(dir, "game-script.xml"))
		self.dialog = DialogDatabase(self, os.path.join(dir, "dialog-database.xml"))

		# list maps in alphabetical order
		maps_by_name = [ (map.name, map) for map in (Map(self, os.path.join(dir, path)) for path in os.listdir(dir) if path.endswith(".tmx")) ]
		maps_by_name.sort();
		self.maps = [ map for _,map in maps_by_name ]
		self.map_dict = dict(maps_by_name)
		for i,m in enumerate(self.maps):
			m.index = i
		
		#validate maps
		if len(self.maps) == 0:
			raise Exception("No maps!")
		# validate map links
		for map in self.maps:
			for gate in (t for t in map.list_triggers() if t.type == TRIGGER_GATEWAY):
				if not gate.target_map in self.map_dict:
					raise Exception("Link to non-existent map: " + gate.target_map)
				tmap = self.map_dict[gate.target_map]
				found = False
				for othergate in (t for t in tmap.list_triggers() if t.type == TRIGGER_GATEWAY):
					if othergate.name == gate.target_gate:
						found = True
						break
				if not found:
					raise Exception("Link to non-existent gate: " + gate.target_gate)
		# validate quests
		for quest in self.script.quests:
			if not quest.map in self.map_dict:
				raise Exception("Unknown map in game script: " + quest.map)

	def export(self):
		with open(os.path.join(self.dir,"content.gen.lua"), "w") as lua:
			lua.write("--GENERATED BY SANDWICH.PY, DO NOT EDIT BY HAND\n")
			lua.write("\n-- MAP IMAGES\n")
			for filename in (os.path.basename(path) for path in os.listdir(self.dir) if path.endswith(".tmx")):
				name = filename[:-4]
				lua.write("TileSet_%s = image{ \"%s.png\", width=16, height=16 }\n" % (name,name))
				if os.path.exists(name + "_overlay.png"):
					lua.write("Overlay_%s = image{ \"%s_overlay.png\", width=16, height=16 }\n" % (name,name))
				lua.write("Blank_%s = image{ \"%s_blank.png\", width=128, height=128 }\n" % (name,name))
			lua.write("\n-- DIALOG IMAGES\n")
			for name in self.dialog.list_npc_image_names():
				lua.write("NPC_%s = image{ \"%s.png\", width=32, height=32, pinned=true }\n" % (name,name))
			for name in self.dialog.list_detail_image_names():
				lua.write("NPC_Detail_%s = image{ \"%s.png\" }\n" % (name,name))
		
		with open(os.path.join(self.dir,"content.gen.cpp"), "w") as src:
			src.write("// GENERATED BY SANDWICH.PY, NO NOT EDIT BY HAND\n")
			src.write("#include \"Content.h\"\n#include \"assets.gen.h\"\n\n")

			for map in self.maps:
				map.write_source_to(src)
			src.write("\nconst MapData gMapData[] = {\n")
			for map in self.maps:
				map.write_decl_to(src)
			src.write("};\n\n")

			src.write("const QuestData gQuestData[] = {\n")
			for q in self.script.quests:
				src.write("    { %d },\n" % self.map_dict[q.map].index)
			src.write("};\n\n")
			src.write("const DialogData gDialogData[] = {};\n\n")

#------------------------------------------------------------------------------
# GAME SCRIPT
#------------------------------------------------------------------------------

class GameScript:
	def __init__(self, world, path):
		self.world = world
		self.path = path
		xml = lxml.etree.parse(path)
		self.quests = [Quest(i, elem) for i,elem in enumerate(xml.findall("quest"))]
		if len(self.quests) > 1:
			for index,quest in enumerate(self.quests[0:-1]):
				for otherQuest in self.quests[index+1:]:
					if quest.id == otherQuest.id:
						raise Exception("Duplicate Quest ID")
		self.quest_dict = dict((quest.id, quest) for quest in self.quests)
	
	def getquest(self, name):
		m = EXP_REGULAR.match(name)
		if m is not None:
			return self.quest_dict[name]
		m = EXP_PLUS.match(name)
		if m is not None:
			return self.quests[self.quest_dict[m.group(1)].index + int(m.group(2))]
		m = EXP_MINUS.match(name)
		if m is not None:
			return self.quests[self.quest_dict[m.group(1)].index - int(m.group(2))]
		raise Exception("Invalid Quest Identifier: " + name)


class Quest:
	def __init__(self, index, xml):
		self.index = index
		self.id = xml.get("id").lower()
		self.map = xml.get("map").lower()
		self.flags = [QuestFloat(i, elem) for i,elem in enumerate(xml.findall("flag"))]
		if len(self.flags) > 32:
			raise Exception("Too Many Flags for Quest: %s" % self.id)
		if len(self.flags) > 1:
			for index,flag in enumerate(self.flags[0:-1]):
				for otherFlag in self.flags[index+1:]:
					if flag.id == otherFlag.id:
						raise Exception("Duplicate Quest Flag ID")
		self.flag_dict = dict((flag.id,flag) for flag in self.flags)

		def getflag(self, name):
			if name in self.flag_dict:
				return self.flag_dict[name]
			raise Exception("Invalid Quest Flag Identifier: " + name)


class QuestFlag:
	def __init__(self, index, xml):
		self.index = index
		self.id = xml.get("id").lower()

#------------------------------------------------------------------------------
# DIALOG DATABASE
#------------------------------------------------------------------------------

class DialogDatabase:
	def __init__(self, world, path):
		self.world = world
		self.path = path
		doc = lxml.etree.parse(path)
		dialogs = [Dialog(node) for node in doc.findall("dialog")]
		if len(dialogs) > 1:
			for i,d in enumerate(dialogs[:-1]):
				for otherd in dialogs[i+1:]:
					if d.id == otherd.id:
						raise Exception("Duplicate Dialog ID")
		# todo: validate dialog images
		self.dialogs = dict((d.id, d) for d in dialogs)

	def list_npc_image_names(self):
		hash = {}
		for dialog in self.dialogs.itervalues():
			if not dialog.npc in hash:
				yield dialog.npc
				hash[dialog.npc] = True
		
	
	def list_detail_image_names(self):
		hash = {}
		for dialog in self.dialogs.itervalues():
			for text in dialog.texts:
				if not text.image in hash:
					yield text.image
					hash[text.image] = True

class Dialog:
	def __init__(self, xml):
		self.id = xml.get("id").lower()
		self.npc = xml.get("npc")
		self.texts = [DialogText(self, i, elem) for i,elem in enumerate(xml.findall("text"))]

class DialogText:
	def __init__(self, dialog, index, xml):
		self.dialog = dialog
		self.index = index
		self.text = xml.text
		# validate text length (prerender?)
		self.image = xml.get("image")


#------------------------------------------------------------------------------
# MAP DATABASE
#------------------------------------------------------------------------------

class Map:
	def __init__(self, world, path):
		self.world = world
		self.name = os.path.basename(path)[:-4].lower()
		if not os.path.exists(path[:-4]+"_blank.png"):
			raise Exception("Map missing blank image: %s_blank.png", self.name)
		self.raw = tmx.Map(path)
		if not "background" in self.raw.layer_dict:
			raise Exception("Map does not contain background layer: %s" % self.name)
		self.background = self.raw.layer_dict["background"]
		if self.background.gettileset().count >= 256:
			raise Exception("Map is too large (must have < 256 tiles): %s" % self.name)
		self.overlay = self.raw.layer_dict.get("overlay", None)
		self.width = self.raw.pw / 128
		self.height = self.raw.ph / 128
		self.count = self.width * self.height
		self.rooms = [Room(self, i) for i in range(self.count)]

		# infer portal states (part of me reeeally wants this to be more clever)
		for r in self.rooms:
			if r.isblocked():
				r.portals[0] = PORTAL_WALLED
				r.portals[1] = PORTAL_WALLED
				r.portals[2] = PORTAL_WALLED
				r.portals[3] = PORTAL_WALLED
				continue
			tx,ty = (8*r.x, 8*r.y)
			# top
			prevType = r.portals[0] = PORTAL_WALLED
			for i in range(8):
				typ = portal_type(self.background.tileat(tx+i, ty))
				if typ == PORTAL_WALLED:
					pass
				elif typ == PORTAL_OPEN:
					if prevType == PORTAL_OPEN:
						r.portals[0] = PORTAL_OPEN
						break
				else:
					r.portals[0] = typ
					break
				prevType = typ
			if r.portals[0] != PORTAL_WALLED and (r.y == 0 or self.roomat(r.x, r.y-1).isblocked()):
				r.portals[0] = PORTAL_WALLED
			# left
			prevType = r.portals[1] = PORTAL_WALLED
			for i in range(8):
				typ = portal_type(self.background.tileat(tx, ty+i))
				if typ == PORTAL_WALLED:
					pass
				elif typ == PORTAL_OPEN:
					r.portals[1] = PORTAL_OPEN
					break
				else:
					r.portals[i] =typ
					break
				prevType = typ
			if r.portals[1] != PORTAL_WALLED and (r.x == 0 or self.roomat(r.x-1, r.y).isblocked()):
				r.portals[1] = PORTAL_WALLED
			# bottom
			prevType = r.portals[2] = PORTAL_WALLED
			for i in range(8):
				typ = portal_type(self.background.tileat(tx+i, ty+7))
				if typ == PORTAL_WALLED:
					pass
				elif typ == PORTAL_OPEN:
					if prevType == PORTAL_OPEN:
						r.portals[2] = PORTAL_OPEN
						break
				else:
					r.portals[2] = typ
					break
				prevType = typ
			if r.portals[2] != PORTAL_WALLED and (r.y == self.height-1 or self.roomat(r.x, r.y+1).isblocked()):
				r.portals[2] = PORTAL_WALLED
			# right
			prevType = r.portals[3] = PORTAL_WALLED
			for i in range(8):
				typ = portal_type(self.background.tileat(tx+7, ty+i))
				if typ == PORTAL_WALLED:
					pass
				elif typ == PORTAL_OPEN:
					r.portals[3] = PORTAL_OPEN
				else:
					r.portals[3] = typ
					break
				prevType = typ
			if r.portals[3] != PORTAL_WALLED and (r.x == self.width-1 or self.roomat(r.x+1, r.y).isblocked()):
				r.portals[3] = PORTAL_WALLED
		# validate portals
		for y in range(self.height):
			if self.roomat(0,y).portals[1] == PORTAL_OPEN or self.roomat(self.width-1, y).portals[3] == PORTAL_OPEN:
				raise Exception("Boundary Wall Error in Map: %s" % self.name)
		for x in range(self.width):
			if self.roomat(x,0).portals[0] == PORTAL_OPEN or self.roomat(x, self.height-1).portals[2] == PORTAL_OPEN:
				raise Exception("Boundary Wall Error in Map: %s" % self.name)
		for x in range(self.width-1):
			for y in range(self.height):
				if self.roomat(x,y).portals[3] != self.roomat(x+1,y).portals[1]:
					raise Exception ("Portal Mismatch in Map: %s" % self.name)
		for x in range(self.width):
			for y in range(self.height-1):
				if self.roomat(x,y).portals[2] != self.roomat(x,y+1).portals[0]:
					raise Exception ("Portal Mismatch in Map: %s" % self.name)
		# unpack triggers
		for obj in self.raw.objects:
			if obj.type in KEYWORD_TO_TRIGGER_TYPE:
				room = self.roomatpx(obj.px, obj.py)
				trig = Trigger(room, obj)
				if trig.name in room.triggers:
					raise Exception("Multiple triggers with the Same Name in the Same Room for map: " + self.name)
				room.triggers[trig.name] = trig

				
	
	def roomat(self, x, y): return self.rooms[x + y * self.width]
	def roomatpx(self, px, py): return self.roomat(px/128, py/128)
	
	def list_triggers(self):
		for r in self.rooms:
			for t in r.triggers.itervalues():
				yield t
	
	def write_source_to(self, src):
		src.write("//--------------------------------------------------------\n")
		src.write("// EXPORTED FROM %s.tmx\n" % self.name)
		src.write("//--------------------------------------------------------\n\n")
		src.write("static const uint8_t %s_xportals[] = {\n" % self.name)
		for y in range(self.height):
			src.write("    ")
			for x in range(self.width):
				src.write(PORTAL_LABELS[self.roomat(x,y).portals[SIDE_LEFT]])
				src.write(", ")
			src.write(PORTAL_LABELS[self.roomat(self.width-1,y).portals[SIDE_RIGHT]])
			src.write(",\n")
		src.write("};\n")
		src.write("static const uint8_t %s_yportals[] = {\n" % self.name)
		for x in range(self.width):
			src.write("    ")
			for y in range(self.height):
				src.write(PORTAL_LABELS[self.roomat(x,y).portals[SIDE_TOP]])
				src.write(", ")
			src.write(PORTAL_LABELS[self.roomat(x, self.height-1).portals[SIDE_BOTTOM]])
			src.write(",\n")
		src.write("};\n")
		# todo: write gateways
		# todo: write items
		# todo: write npcs
		if self.overlay is not None:
			for room in self.rooms:
				if room.hasoverlay():
					src.write("static const uint8_t %s_overlay_%d_%d[] = {\n" % (self.name, room.x, room.y))
					src.write("    ")
					for y in range(8):
						for x in range(8):
							tile = room.overlaytileat(x,y)
							if tile is not None:
								src.write("%s, %s, " % (hex(x<<4|y), hex(tile.lid)))
					src.write("0xff \n};\n")
		src.write("static const RoomData %s_rooms[] = {\n" % self.name)
		for y in range(self.height):
			for x in range(self.width):
				room = self.roomat(x,y)
				room.write_source_to(src)
		src.write("};\n")
	
	def write_decl_to(self, src):
		if self.overlay is not None:
			overlay_msg = "&Overlay_" + self.name
		else:
			overlay_msg = "0"
		src.write(
			"    { &TileSet_%s, %s, &Blank_%s, %s_rooms, %s_xportals, %s_yportals, %d, %d, 0, 0 },\n" % \
			(self.name, overlay_msg, self.name, self.name, self.name, self.name, self.width, self.height))
		


class Room:
	def __init__(self, map, lid):
		self.map = map
		self.lid = lid
		self.x = lid % map.width
		self.y = lid / map.width
		self.portals = [ PORTAL_WALLED, PORTAL_WALLED, PORTAL_WALLED, PORTAL_WALLED ]
		self.triggers = {}

	def hasitem(self): return len(self.item) > 0 and self.item != "ITEM_NONE"
	def tileat(self, x, y): return self.map.background.tileat(8*self.x + x, 8*self.y + y)
	def overlaytileat(self, x, y): return self.map.overlay.tileat(8*self.x + x, 8*self.y + y)

	def listtorchtiles(self):
		for x in range(8):
			for y in range(8):
				if istorch(self.tileat(x,y)) and (y == 0 or not istorch(self.tileat(x,y-1))):
					yield (x,y) 
	
	def center(self):
		for (x,y) in misc.spiral_into_madness():
			if iswalkable(self.tileat(x-1, y)) and iswalkable(self.tileat(x,y)):
				return self.adjust(x,y)
		return (0,0)
	
	def adjust(self, x, y):
		if ispath(self.tileat(x-1,y)):
			if not ispath(self.tileat(x,y)) and ispath(self.tileat(x-2,y)):
				x-=1
		elif ispath(self.tileat(x,y)) and ispath(self.tileat(x+1,y)):
			x+=1
		return (x,y)
	
	def isblocked(self): return self.center() == (0,0)

	def hasoverlay(self):
		if self.map.overlay is None: return False
		for y in range(8):
			for x in range(8):
				if self.overlaytileat(x,y) is not None:
					return True
		return False
	
	def write_source_to(self, src):
		src.write("    {\n")
		# collision mask rows
		src.write("        {\n            ")
		for row in range(8):
			rowMask = 0
			for col in range(8):
				if not iswalkable(self.tileat(col, row)):
					rowMask |= (1<<col)
			src.write("%s, " % hex(rowMask))
		src.write("\n        },\n")
		# tiles
		src.write("        {\n")
		for ty in range(8):
			src.write("            ")
			for tx in range(8):
				src.write("%s, " % hex(self.tileat(tx,ty).lid))
			src.write("\n")
		src.write("        },\n")
		# overlay
		if self.hasoverlay():
			src.write("        %s_overlay_%d_%d, " % (self.map.name, self.x, self.y))
		else:
			src.write("        0, ")
		# centerx, centery, reserved
		cx,cy = self.center()
		src.write("%d, %d, 0,\n" % (cx, cy))

		# torches - should be moved out to a flat list like items / etc
		#torchcount = 0
		#for tx,ty in self.listtorchtiles():
		#	if torchcount == 2:
		#		raise Exception("Too man torches in one room (capacity 2): "  + self.name)
		#	src.write("        %s,\n" % hex((tx<<4) + ty))
		#	torchcount+=1
		#for i in range(2-torchcount):
		#	src.write("        0xff,\n")
		src.write("    },\n")		

class Trigger:
	def __init__(self, room, obj):
		self.name = obj.name
		self.room = room
		self.raw = obj
		self.type = KEYWORD_TO_TRIGGER_TYPE[obj.type]
		# deterine quest state
		if "quest" in obj.props:
			self.quest = room.map.world.script.getquest(obj.props["quest"])
			if "questflag" in obj.props:
				self.qflag = self.quest.getflag(obj.props["questflag"])
		else:
			if "minquest" in obj.props:
				self.minquest = room.map.world.script.getquest(obj.props["minquest"])
			if "maxquest" in obj.props:
				self.maxquest = room.map.world.script.getquest(obj.props["maxquest"])
			if hasattr(self, "minquest") and hasattr(self, "maxquest"):
				if self.minquest.index > self.maxquest.index:
					raise Exception("MaxQuest > MinQuest for object in map: " + room.map.name)
		if self.type == TRIGGER_ITEM:
			self.itemid = int(obj.props["id"])
			# validate?
		elif self.type == TRIGGER_GATEWAY:
			m = EXP_GATEWAY.match(obj.props.get("target", ""))
			if m is None:
				raise Exception("Malformed Gateway Target in Map: " + room.map.name)
			self.target_map = m.group(1)
			self.target_gate = m.group(2)
		elif self.type == TRIGGER_NPC:
			did = obj.props["id"]
			if not did in room.map.world.dialog.dialogs:
				raise Exception("Invalid Dialog ID in Map: " + room.map.name)
			self.dialog = room.map.world.dialog.dialogs[did]

#------------------------------------------------------------------------------
# HELPERS
#------------------------------------------------------------------------------

def istorch(tile): return "torch" in tile.props
def isobst(tile): return "obstacle" in tile.props or istorch(tile)
def iswall(tile): return "wall" in tile.props
def isdoor(tile): return "door" in tile.props
def isopen(tile): return not isdoor(tile) and not isobst(tile) and not iswall(tile)
def iswalkable(tile): return not iswall(tile) and not isobst(tile)
def ispath(tile): return not "path" in tile.props

def portal_type(tile):
	if isdoor(tile):
		return PORTAL_DOOR
	elif iswall(tile) or isobst(tile):
		return PORTAL_WALLED
	else:
		return PORTAL_OPEN
